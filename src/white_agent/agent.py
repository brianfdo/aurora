"""
Aurora White Agent - Deterministic Playlist Generator

Refactored to follow A2A Starlette format while keeping deterministic logic.
"""

import json
import uvicorn
import os
import dotenv

try:
    from a2a.server.apps import A2AStarletteApplication
    from a2a.server.request_handlers import DefaultRequestHandler
    from a2a.server.agent_execution import AgentExecutor, RequestContext
    from a2a.server.events import EventQueue
    from a2a.server.tasks import InMemoryTaskStore
    from a2a.types import AgentSkill, AgentCard, AgentCapabilities
    from a2a.utils import new_agent_text_message, get_text_parts
    A2A_AVAILABLE = True
except ImportError:
    A2A_AVAILABLE = False

dotenv.load_dotenv()


def prepare_white_agent_card(url: str) -> AgentCard:
    """Prepare agent card for white agent."""
    skill = AgentSkill(
        id="playlist_generation",
        name="Playlist Generation",
        description="Generates travel playlist code using deterministic template-based approach",
        tags=["music", "playlist", "deterministic"],
        examples=[],
    )
    card = AgentCard(
        name="aurora_white_agent",
        description="Deterministic playlist generator for Aurora benchmark",
        url=url,
        version="1.0.0",
        default_input_modes=["text/plain"],
        default_output_modes=["text/plain"],
        capabilities=AgentCapabilities(),
        skills=[skill],
    )
    return card


class AuroraWhiteAgentExecutor(AgentExecutor):
    """
    White agent executor that generates playlist code deterministically.
    
    Keeps the exact same logic as the original WhiteAgent.
    """
    
    def __init__(self):
        self.ctx_id_to_messages = {}
    
    def _generate_code(self, task_id: str, route: dict, instruction: str) -> str:
        """
        Generate code deterministically based on route.
        
        No LLM - pure template-based generation.
        Same logic as original WhiteAgent.
        """
        legs = route.get('legs', [])
        
        code_lines = [
            f"# Task: {task_id}",
            "# Generated by deterministic white agent",
            "playlist = []",
            "",
        ]
        
        # Generate code for each leg
        for leg in legs:
            city = leg.get('city', '')
            leg_id = leg.get('leg_id', '')
            
            code_lines.extend([
                f"# Leg: {city}",
                f"city = '{city}'",
                f"# Search for tracks related to {city}",
                f"tracks = apis.spotify.search_tracks(query=f\"{{city}} music\", limit=3)",
                "",
                "playlist.append({",
                f"    'leg_id': '{leg_id}',",
                f"    'city': city,",
                "    'tracks': tracks[:3] if isinstance(tracks, list) else []",
                "})",
                "",
            ])
        
        return "\n".join(code_lines)
    
    async def execute(self, context: RequestContext, event_queue: EventQueue) -> None:
        """
        Execute task - receives task description and generates code.
        
        Parses the task from user input and returns generated code.
        Supports multiple input formats:
        1. Structured text: "Task ID: ...\nRoute: {...}\n..."
        2. JSON object
        3. Natural language instruction
        """
        user_input = context.get_user_input()
        
        task_id = 'unknown'
        route = {}
        instruction = ''
        
        # Try to parse structured format first (from green agent)
        if 'Task ID:' in user_input and 'Route:' in user_input:
            lines = user_input.split('\n')
            for i, line in enumerate(lines):
                if line.startswith('Task ID:'):
                    task_id = line.split(':', 1)[1].strip()
                elif line.startswith('Instruction:'):
                    instruction = line.split(':', 1)[1].strip()
                    # Instruction might continue on next lines
                    for j in range(i+1, len(lines)):
                        next_line = lines[j]
                        if next_line.startswith('Route:') or next_line.startswith('Allowed apps:'):
                            break
                        if next_line.strip() and not next_line.startswith('Please'):
                            instruction += " " + next_line.strip()
                elif line.startswith('Route:'):
                    # Extract JSON from line (everything after "Route:")
                    route_part = line.split(':', 1)[1].strip()
                    
                    # Try direct parse first (most common case - JSON on same line)
                    try:
                        route = json.loads(route_part)
                    except json.JSONDecodeError:
                        # If JSON spans multiple lines, collect until we see }
                        route_json_str = route_part
                        if not route_json_str.rstrip().endswith('}'):
                            for j in range(i+1, min(i+20, len(lines))):
                                next_line = lines[j].strip()
                                # Stop if we hit "Allowed apps" or empty line after having JSON start
                                if next_line.startswith('Allowed apps:') or \
                                   (not next_line and '{' in route_json_str):
                                    break
                                route_json_str += next_line
                        
                        # Try parsing the collected string
                        try:
                            route = json.loads(route_json_str)
                        except json.JSONDecodeError:
                            # Last resort: use regex to find JSON object
                            import re
                            # Match JSON object in the route line or full input
                            json_match = re.search(r'Route:\s*(\{.*?\})', user_input, re.DOTALL)
                            if json_match:
                                try:
                                    route = json.loads(json_match.group(1))
                                except:
                                    # Try finding any JSON with "start" and "legs"
                                    json_match2 = re.search(r'\{"start"[^}]*"end"[^}]*"legs".*?\}', user_input, re.DOTALL)
                                    if json_match2:
                                        try:
                                            route = json.loads(json_match2.group())
                                        except:
                                            pass
        
        # If we still don't have a route, try extracting from full input using regex
        if not route or not route.get('legs'):
            import re
            # Look for JSON object after "Route:" keyword
            route_match = re.search(r'Route:\s*(\{[^}]*"start"[^}]*"end"[^}]*"legs".*?\})', user_input, re.DOTALL)
            if route_match:
                try:
                    route = json.loads(route_match.group(1))
                except json.JSONDecodeError:
                    # Try finding any JSON with "start", "end", "legs" anywhere in input
                    json_match = re.search(r'(\{[^}]*"start"[^}]*"end"[^}]*"legs".*?\})', user_input, re.DOTALL)
                    if json_match:
                        try:
                            route = json.loads(json_match.group(1))
                        except:
                            pass
            
            # Also try parsing as full JSON object
            if (not route or not route.get('legs')) and user_input.strip().startswith('{'):
                try:
                    task_data = json.loads(user_input)
                    if isinstance(task_data, dict):
                        route = task_data.get('route', route)
                        task_id = task_data.get('task_id', task_id)
                except:
                    pass
        
        # Generate code using deterministic template
        code = self._generate_code(task_id, route, instruction)
        
        # Return code as response
        response_text = f"Generated code for task {task_id}:\n\n```python\n{code}\n```"
        
        await event_queue.enqueue_event(
            new_agent_text_message(
                response_text, context_id=context.context_id
            )
        )
    
    async def cancel(self, context: RequestContext, event_queue: EventQueue) -> None:
        raise NotImplementedError


def start_white_agent(agent_name: str = "aurora_white_agent", host: str = "localhost", port: int = 9000):
    """
    Start the Aurora white agent using A2A Starlette application.
    
    Keeps deterministic logic while using A2A format.
    """
    if not A2A_AVAILABLE:
        raise ImportError(
            "a2a-sdk required. Install: pip install 'a2a-sdk[http-server]' uvicorn\n"
            "Or use: uv sync (if using uv)"
        )
    
    print("Starting Aurora white agent...")
    url = os.getenv("AGENT_URL") or f"http://{host}:{port}"
    card = prepare_white_agent_card(url)
    
    # Create executor instance for /solve endpoint
    executor = AuroraWhiteAgentExecutor()
    
    request_handler = DefaultRequestHandler(
        agent_executor=executor,
        task_store=InMemoryTaskStore(),
    )
    
    app = A2AStarletteApplication(
        agent_card=card,
        http_handler=request_handler,
    )
    
    # Build the Starlette app first
    starlette_app = app.build()
    
    # Add custom routes for backward compatibility with green agent
    from starlette.routing import Route
    from starlette.responses import JSONResponse
    
    async def solve_endpoint(request):
        """Backward compatible /solve endpoint for green agent."""
        data = await request.json()
        task_id = data.get('task_id', '')
        route = data.get('route', {})
        instruction = data.get('instruction', '')
        
        code = executor._generate_code(task_id, route, instruction)
        
        return JSONResponse({
            'code': code,
            'task_id': task_id,
            'method': 'deterministic_template'
        })
    
    async def health_endpoint(request):
        """Health check endpoint."""
        return JSONResponse({
            'status': 'healthy',
            'agent': 'Aurora White Agent',
            'type': 'deterministic'
        })
    
    # Add routes to the Starlette app
    starlette_app.routes.extend([
        Route('/solve', solve_endpoint, methods=['POST']),
        Route('/health', health_endpoint, methods=['GET']),
    ])
    
    print(f"ðŸŽµ Aurora White Agent - A2A Server")
    print(f"âœ“ Deterministic code generation")
    print(f"âœ“ No LLM dependencies")
    print(f"âœ“ Listening on {host}:{port}")
    print(f"âœ“ Agent URL: {url}")
    print("=" * 70)
    
    uvicorn.run(starlette_app, host=host, port=port)


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Aurora White Agent")
    parser.add_argument("--host", default="localhost", help="Host to bind to")
    parser.add_argument("--port", default=9000, type=int, help="Port to listen on")
    parser.add_argument("--agent-name", default="aurora_white_agent", help="Agent name")
    args = parser.parse_args()
    
    start_white_agent(agent_name=args.agent_name, host=args.host, port=args.port)
